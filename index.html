<!DOCTYPE html>
<html>
<head>
    <title>amaurs</title>
    <link href="style/style.css" type="text/css" rel="stylesheet" />
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
        });
    </script>
</head>
<body>
    <div class="images-container" id="content">
        <h1>Weighted Voronoi Stipples</h1>
        <p>Pointillism is the process of representing the tone of an image by drawing carefully selected points. The usual aproach is to create a regular grid over the image and place a point with the color that the pixel in place has. Using this method and 900 points we obtain the picture below.</p>
        <div class="images-container" id="robot-regular">
            <svg class="svg-robot" id="svg-regular" width="480" height="480"></svg>
        </div>
        <p>The problem with this approach is that many of the points are placed in areas with little information. These end up being painted with the color backgroung. We are interested in placing points where we have more information. Acceptance rejection method can help us here, we start with the same amount of points but we will place them in an stochastic fashion. We randomly pick a pixel in the image and calculate its brightness as:</p>

        <p>$\mu = \frac{.3 \times R + .59 \times G + .11 \times B}{255}$</p>

        <p>A random uniform number is then generated, if the number is bigger that the pixel's brightness, we accept the point and we continue this method until we have a sample of the requiered size. Using this approach, the point distribution resembles more clearly the original image.</p>
        <div class="images-container" id="robot-rejection">
            <svg class="svg-robot" id="svg-rejection" width="480" height="480"></svg>
        </div>
        <p>Even though this method represents the image in a better way, the result looks messier. Adrian Secord proposed an iterative algorithm to rearange the points taken from the acceptance rejection method. In this process, we calculate the centroids of the Voronoi cells generated by the set of initial points. We create a new Voronoi diagram with the centroids of the previous iteration and repeat the process until we are satisfied with the result. In the image below, the process is repeated 20 times.</p>
        <div class="images-container" id="robot-voronoi">
            <svg class="svg-robot" id="svg-voronoi" width="480" height="480"></svg>
        </div>
        <p>A more pleasent result is obtained. In the following figure we can interact with the process by clicking on the image, the Voronoi cells and the Delaunay triangulation are shown for the set of points. Each click will iterate on the points by moving each point to its cell center.</p>

        <div id="robot-interactive">
            <div class="images-container"></div>
                <button id="toggle" type="button">Hide Grid</button>
                <button id="restart" type="button">Restart</button>
            </div>
            <div class="images-container" id="robot-images">
                <svg class="svg-robot" id="svg-voronoi-interactive" width="480" height="480"></svg>
            </div>
        </div>

        <script src="bower_components/d3/d3.js"></script>
        <script src="bower_components/MathJax/MathJax.js?config=TeX-AMS_HTML-full"></script>
        <script src="js/util.js"></script>
        <script src="js/main.js"></script>
    </div>
</body>
</html>